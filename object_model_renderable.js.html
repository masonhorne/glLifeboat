<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: object/model/renderable.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: object/model/renderable.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
'use strict';
import { throwAbstractClassError } from "../utility/logging.js";
import { createProgram, createShader } from "../utility/webglutils.js";
import { multiply, projection } from "../utility/math.js";

const vertexShaderSource = `
    // Attribute to receive data from buffer
    attribute vec4 position;
    // Attribute for the color
    attribute vec4 vertexColor;
    // Uniform to receive point size from buffer
    uniform float pointSize;
    // Uniform to convert coordinate position to clipspace
    uniform mat4 projection;
    // Color value to pass on to fragment shader
    varying vec4 color;
    // Main function for the shader
    void main () {
        // Set position with to coordinate with z of 0 and w of 1
        gl_Position = projection * position;
        // Set the point size provided
        gl_PointSize = pointSize;
        // Update the color value for the fragment
        color = vertexColor;
    }
`;

const fragmentShaderSource = `
    // Fragment shaders don't have precision set so default to medium
    precision mediump float;
    // Get the color for this pixel from varying
    varying vec4 color;
    // Main function for the shader
    void main() {
        // gl_FragColor is the special variable a fragment shader sets
        gl_FragColor = color;
    }
`;

/**
 * This is an abstract class for objects that can be rendered on the canvas
 */
export class Renderable {

    /**
     * Renderable is an abstract class and should not be instantiated
     */
    constructor() {
        if(this.constructor.name == Renderable) {
            throwAbstractClassError(this.constructor.name);
        }
    }

    /**
     * Render the object to the canvas of the provided context
     * 
     * @param {WebGLRenderingContext} gl rendering context for the canvas
     */
    render(gl) {
        throwAbstractClassError(this.constructor.name);
    }

    /**
     * Initializes and binds the position buffer
     * @param {WebGLRenderingContext} gl rendering context for the canvas
     */
    setupPositionBuffer(gl){
        this.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    }

    /**
     * Processes the values inside of the position buffer
     * @param {WebGLRenderingContext} gl rendering context for the canvas
     */
    processPositionBuffer(gl) {
        gl.enableVertexAttribArray(this.positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
        const size = 3, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;
        gl.vertexAttribPointer(this.positionAttributeLocation, size, type, normalize, stride, offset);
    }

    /**
     * Initializes and binds the color buffer
     * @param {WebGLRenderingContext} gl rendering context for the canvas
     */
    setupColorBuffer(gl){
        this.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    }

    /**
     * Processes the values inside of the color buffer
     * @param {WebGLRenderingContext} gl rendering context for the canvas
     */
    processColorBuffer(gl) {
        gl.enableVertexAttribArray(this.colorAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        const size = 3, type = gl.UNSIGNED_BYTE, normalize = true, stride = 0, offset = 0;
        gl.vertexAttribPointer(this.colorAttributeLocation, size, type, normalize, stride, offset);
    }

    /**
     * Initialize a 3d shader program that reads pixel coordinates
     * 
     * @param {WebGLRenderingContext} gl rendering context for the canvas
     * @returns true if initialization is successful and false otherwise
     */
    initPixelRender(gl) {
        if (gl === null) {
            console.log("Error retrieving canvas context.");
            return false;
        }
        // Create program to render
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        this.program = createProgram(gl, vertexShader, fragmentShader);
        // Get attribute and uniform locations
        this.positionAttributeLocation = gl.getAttribLocation(this.program, "position");
        this.colorAttributeLocation = gl.getAttribLocation(this.program, "vertexColor");
        this.pointSizeUniformLocation = gl.getUniformLocation(this.program, "pointSize");
        const projectionUniformLocation = gl.getUniformLocation(this.program, "projection");
        // Choose program for rendering
        gl.useProgram(this.program);
        // Calculate the projection matrix based on the renderables settings
        let projectionMatrix = projection(gl.canvas.clientWidth,
            gl.canvas.clientHeight,
            Math.max(gl.canvas.clientWidth, gl.canvas.clientHeight)
        );
        let offsetMatrix = this.calculateOffset();
        if(offsetMatrix.length !== 0) {
            projectionMatrix = multiply(offsetMatrix, projectionMatrix);
        }
        let rotationMatrix = this.calculateRotation();
        if(rotationMatrix.length !== 0) {
            projectionMatrix = multiply(rotationMatrix, projectionMatrix);
        }
        // Provide the projection matrix for this object to shader
        gl.uniformMatrix4fv(projectionUniformLocation,
            false,
            projectionMatrix
        );
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        return true;
    }

    /**
     * Extend a renderable object and override this function to provide update behavior to the object
     */
    update() {}

    /**
     * Calculates and returns the current renderables rotation matrix
     */
    calculateRotation() { return []; }

    /**
     * Calculates and returns the current renderables offset matrix from origin
     */
    calculateOffset() { return []; }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Black.html">Black</a></li><li><a href="Blue.html">Blue</a></li><li><a href="Brown.html">Brown</a></li><li><a href="Burgandy.html">Burgandy</a></li><li><a href="Color.html">Color</a></li><li><a href="Cube.html">Cube</a></li><li><a href="Cuboid.html">Cuboid</a></li><li><a href="CuboidRenderSettings.html">CuboidRenderSettings</a></li><li><a href="Green.html">Green</a></li><li><a href="Grey.html">Grey</a></li><li><a href="Lifeboat.html">Lifeboat</a></li><li><a href="Magenta.html">Magenta</a></li><li><a href="Pink.html">Pink</a></li><li><a href="Point.html">Point</a></li><li><a href="PointRenderSetting.html">PointRenderSetting</a></li><li><a href="Purple.html">Purple</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="Red.html">Red</a></li><li><a href="Renderable.html">Renderable</a></li><li><a href="Shape.html">Shape</a></li><li><a href="Teal.html">Teal</a></li><li><a href="Triangle.html">Triangle</a></li><li><a href="Violet.html">Violet</a></li><li><a href="White.html">White</a></li><li><a href="Yellow.html">Yellow</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createProgram">createProgram</a></li><li><a href="global.html#createShader">createShader</a></li><li><a href="global.html#degreeToRadian">degreeToRadian</a></li><li><a href="global.html#identity">identity</a></li><li><a href="global.html#multiply">multiply</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#randomInt">randomInt</a></li><li><a href="global.html#resetForRender">resetForRender</a></li><li><a href="global.html#resizeCanvasToDisplaySize">resizeCanvasToDisplaySize</a></li><li><a href="global.html#rotationX">rotationX</a></li><li><a href="global.html#rotationY">rotationY</a></li><li><a href="global.html#rotationZ">rotationZ</a></li><li><a href="global.html#scale">scale</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#throwAbstractClassError">throwAbstractClassError</a></li><li><a href="global.html#throwMatrixMultiplyError">throwMatrixMultiplyError</a></li><li><a href="global.html#translation">translation</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Jul 03 2023 04:38:58 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
